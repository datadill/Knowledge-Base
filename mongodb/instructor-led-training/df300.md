# DF300

## Expression Stages

### $project

* Good for creating brand new fields or renaming fields
* Only sends new fields you specify from one stage to the next

### $set

* $set is very similar to project, but the major difference is that $set will forward ALL of the fields of the document as well as the ones you $set
* From a performance perspective, the instructor said that $project is not necessarily faster than $set even though you are likely returning less fields in $project

### $group

* Roughly equivalent to GROUP BY in SQL
* Groups documents by a "group key"
* Output is one document per group
* Additional fields can contain results of accumulator expressions

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

* Common $group accumulators
  * $addToSet, $avg, $first, $last, $max, $min, $mergeObjects, $push, $stdDevSamp, $sum
  * Also.. $bucket, $bucketAuto, $facet
    * $bucket is good to segregate data
      * ex. Group data by month
  * $sortByCount
    * Really common for DBAs and developers
    * Returns a frequency count of a field across all of your documents
  * $unwind
    * Opposite of $group, it will unwind an array into multiple documents with the same \_id
      * Because this is a stage during the pipeline in memory, this does not cause any issues

### $lookup

* Like a left outer join, but much more closely aligns to a nested select in terms of performance
  * MongoDB is NOT a relational database!
* Good for analytic purposes mostly
  * Their is one edge case that is acceptable in OLTP applications..
    * ex. When one collection is very static and another is extremely active (updates every few milliseconds)
* No referential integrity is enforced with this operation
* If their is more than one match on the right side of the join, it will put the results into an array
* For each document in the left side of the join, you will have to iteratively scan the right side collection
  * You MUST index the foreign field (right side)
  * It is also recommended to index the local field (left side)
* If their is no match, their is nothing to attach the join to and thus that field will not be attached
* Be careful of cross joining NULL values as NULL is considered a value in Mongo



## Output Stage

### $out

* Write results to a new collection

### $merge

* Update an existing collection
  * Add new documents or edit existing
* Updates existing fields or appends new ones

### $set

* Add extra fields without $projecting all of them

### $replaceRoot

* Create a whole new shape of top-level document
* Very similar to $merge, but $replaceRoot will just fully replace the document
* \_id remains the same

### $sample

* Choose a random set of docs from the input



## Database Internal Stats Stages

Requires elevated permissions to access diagnostic information

* $collStats
  * Describe collection statistics
* $currentOp
  * List ongoing database operations
* $indexStats
  * Are people actually using indexes since boot
* $listSessions
  * Show ho is connected and what are they doing
* $planCacheStats
  * Show what query shapes are cached and the query plans

## Aggregation Optimization

Common mistakes:

* Often developers will think that $project reduces the fields outputted into the next stage, but Mongo will actually use the entire document throughout the pipeline
  * Generally speaking, $project should be towards the end
    * This doesn't actually have any performance impact, but it makes it clear that their is no advantage to putting it at the beginning
* Stages can be streaming or blocking
  * A blocking stage will block subsequent streaming stages

## Aggregation and Memory Usage

* Documents inside the pipeline can be up to 64mb in size
* Final stage must be 16mb or less as they need to be BSON
  * This can be broken during the pipeline/computation phase, but at the end of the process you have to be under 16mb
* Blocking stages can use up to 100mb of heap RAM
  * If you need more, you can write to disk
    * $sort, $group, $bucket, and $bucketAuto can use disk with allowDiskUse:true
      * **WARNING: THIS WILL INCREASE IOPs FOR THE ENTIRE DATBASE AND IT SHOULD BE AVOIDED AT ALL COSTS IN PRODUCTION**
      * You can see this in db.currentOp and in the explain plan look for that specific type of operation
